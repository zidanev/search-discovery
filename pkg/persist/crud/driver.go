// Package crud implement data to object struct and object-relational mapping.
// using ent framework makes it easy to build and maintain with large data-models.
// Schema As Code - model any database schema as Go objects.
// Multi Storage Driver - supports MySQL, MariaDB, TiDB, PostgresSQL, CockroachDB, SQLite and Gremlin.
// # This manifest was generated by ymir. DO NOT EDIT.
package crud

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"ariga.io/atlas/sql/migrate"
	entDialect "entgo.io/ent/dialect"
	sqlDialect "entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/schema"
	pkgInf "github.com/kubuskotak/asgard/infrastructure"
	pkgTracer "github.com/kubuskotak/asgard/tracer"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"go.opentelemetry.io/otel/codes"

	"github.com/kubuskotak/king/pkg/infrastructure"
	"github.com/kubuskotak/king/pkg/persist/crud/ent"
	_ "github.com/kubuskotak/king/pkg/persist/crud/ent/runtime"
)

var (
	// ErrNotFound is the error returned by driver if a resource cannot be found.
	ErrNotFound = errors.New("not found")

	// ErrAlreadyExists is the error returned by driver if a resource ID is taken during a creation.
	ErrAlreadyExists = errors.New("already exists")

	// ErrNotSingular is the error returned by driver if a resource is not a single.
	ErrNotSingular = errors.New("record is not single")
)

// Database is data of instances.
type Database struct {
	*ent.Client
	dialect   string
	driver    *sqlDialect.Driver
	txOptions *sql.TxOptions
}

// WithDriver sets sql driver and dialect.
func WithDriver(s *sqlDialect.Driver, dialect string) func(*Database) {
	return func(d *Database) {
		d.driver = s
		d.dialect = dialect
	}
}

// WithTxIsolationLevel sets correct isolation level for database transactions.
func WithTxIsolationLevel(level sql.IsolationLevel) func(*Database) {
	return func(h *Database) {
		h.txOptions = &sqlDialect.TxOptions{Isolation: level}
	}
}

// Driver - wrapper sql driver to ent client.
func Driver(cfg ...func(database *Database)) *Database {
	db := &Database{}
	for _, f := range cfg {
		f(db)
	}
	opts := make([]ent.Option, 0)
	if strings.EqualFold(infrastructure.Envs.App.Environment, pkgInf.Development) {
		driverWithDebugContext := entDialect.DebugWithContext(db.driver,
			func(ctx context.Context, i ...any) {
				var _, span, l = pkgTracer.StartSpanLogTrace(ctx, "SQL Operation")
				defer span.End()
				l.Debug().Str("query", fmt.Sprintf("%v", i)).Msg("driverWithDebugContext")
			})
		opts = append(opts, ent.Driver(driverWithDebugContext))
	} else {
		var driverWithTracer = pkgTracer.EntDriverWithContext(db.driver,
			func(ctx context.Context, level zerolog.Level, msg string, err error) {
				var _, span, l = pkgTracer.StartSpanLogTrace(ctx, "SQL Operation")
				switch level {
				case zerolog.ErrorLevel:
					span.SetStatus(codes.Error, "EntDriverWithContext logging")
					span.RecordError(err)
					l.Error().Err(err).Msg(msg)
				case zerolog.InfoLevel:
					span.SetStatus(codes.Ok, "EntDriverWithContext logging")
					l.Info().Msg(msg)
				default:
					l.Debug().Err(err).Msg(msg)
				}
				span.End()
			})
		opts = append(opts, ent.Driver(driverWithTracer))
	}
	db.Client = ent.NewClient(opts...)

	temp := filepath.Join(os.TempDir(), "migrations")
	if err := embedWriteTemp(temp, db.dialect); err != nil {
		log.Error().Err(err).Msg("migrate schema is failed")
		//nolint: revive
		os.Exit(1)
	}

	dir, err := migrate.NewLocalDir(temp)
	if err != nil {
		log.Error().Err(err).Msg("migrate schema is failed")
		//nolint: revive
		os.Exit(1)
	}

	options := []schema.MigrateOption{
		schema.WithDir(dir),
		schema.WithMigrationMode(schema.ModeReplay), // provide migration mode
		schema.WithDialect(db.dialect),
		schema.WithDropColumn(true),
		schema.WithDropIndex(true),
	}
	ctx := context.Background()
	if err = db.Client.Schema.Create(ctx, options...); err != nil {
		log.Error().Err(err).Msg("migrate schema is failed")
		//nolint: revive
		os.Exit(1)
	}
	if err = os.RemoveAll(temp); err != nil {
		log.Error().Err(err).Msg("failed to remove temporary directory for database migrations")
	}

	return db
}

// WithTransaction is a wrapper to begin transaction with defined options.
func (d *Database) WithTransaction(ctx context.Context, fn func(ctx context.Context, tx *ent.Tx) error) error {
	tx, err := d.Client.BeginTx(ctx, d.txOptions)
	if err != nil {
		return err
	}

	if err = fn(ctx, tx); err != nil {
		if errRoll := tx.Rollback(); errRoll != nil {
			return fmt.Errorf("tx err: %v, rb err: %v", err, errRoll)
		}
		return d.ConvertDBError("execute:", err)
	}
	if err = tx.Commit(); err != nil {
		if errRoll := tx.Rollback(); errRoll != nil {
			return d.ConvertDBError("rollback:", errRoll)
		}
		return d.ConvertDBError("commit is failed", err)
	}
	return nil
}

// BeginTx is a wrapper to begin transaction with defined options.
func (d *Database) BeginTx(ctx context.Context) (*ent.Tx, error) {
	return d.Client.BeginTx(ctx, d.txOptions)
}

// ConvertDBError set wrapper db error.
func (*Database) ConvertDBError(t string, err error) error {
	switch {
	case ent.IsValidationError(err):
		valid := err.(*ent.ValidationError)
		return fmt.Errorf("validator failed for field: %s", valid.Name)
	case ent.IsNotSingular(err):
		return fmt.Errorf("%s: %v", t, ErrNotSingular)
	case ent.IsConstraintError(err):
		return fmt.Errorf("%s %v or %v", t, ErrAlreadyExists, err.(*ent.ConstraintError).Unwrap())
	case ent.IsNotFound(err):
		return fmt.Errorf("%s: %v", t, ErrNotFound)
	default:
		return fmt.Errorf("%s: %v", t, err)
	}
}
